/////////////////////////////////////////////////////////////////////////
//                                                                     //
//   Modulename :  stage_if.sv                                         //
//                                                                     //
//  Description :  instruction fetch (IF) stage of the pipeline;       //
//                 fetch instruction, compute next PC location, and    //
//                 send them down the pipeline.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

`include "verilog/sys_defs.svh"

module stage_if (
	//System Signals
	input clock,                  // system clock
	input reset,                  // system reset

	//Control Signals
	input dp_stall,                  // signal from insn_buffer
	input squash_en,              // from Retire stage, 1 if squashing is needed
	input                      [`XLEN-1:0] squashed_new_PC_in,
	//From Excute taken signal
	input  bp_taken,

	// //From Branch Prediction
	// input  			  	 [`IF_SIZE-1:0] [`XLEN-1:0] bp_pc, bp_npc,
	// //To Branch Prediction
	// output IF_DP_PACKET     [`IF_SIZE-1:0] if_bp_packet_out,

	//From ICache
	input  ICACHE_IF_PACKET [`IF_SIZE-1:0] icache_if_packet_in,
	//To ICache
	output IF_ICACHE_PACKET [`IF_SIZE-1:0] if_icache_packet_out

	//To Instruction Buffer
	output IF_DP_PACKET     [`IF_SIZE-1:0] if_dp_packet_out,
);

    logic [`XLEN-1:0] PC_reg; // PC we are currently fetching

    // synopsys sync_set_reset "reset"
    always_ff @(posedge clock) begin
        if (reset) begin
            PC_reg <= 0;             // initial PC value is 0 (the memory address where our program starts)
        end else if (take_branch) begin
            PC_reg <= branch_target; // update to a taken branch (does not depend on valid bit)
        end else if (if_valid) begin
            PC_reg <= PC_reg + 4;    // or transition to next PC if valid
        end
    end

    // address of the instruction we're fetching (64 bit memory lines)
    // mem always gives us 8=2^3 bytes, so ignore the last 3 bits
    assign proc2Imem_addr = {PC_reg[`XLEN-1:3], 3'b0};

    // this mux is because the Imem gives us 64 bits not 32 bits
    assign if_packet.inst = (~if_valid) ? `NOP :
                            PC_reg[2] ? Imem2proc_data[63:32] : Imem2proc_data[31:0];

    assign if_packet.PC  = PC_reg;
    assign if_packet.NPC = PC_reg + 4; // pass PC+4 down pipeline w/instruction

    assign if_packet.valid = if_valid;

endmodule // stage_if

module Branch_Prediction (
    ports
);

    logic [`XLEN-1:0] PC_reg; // PC we are currently fetching

    /********Branch Prediction Logic**********/
    logic [11:0]tag [0:3];
    logic [`XLEN-1:0]target [0:3];
    logic hit; logic [1:0] hittarget;
    logic [1:0] tagindex;
    logic [1:0] state;
    logic taken;
    integer i;

    // synopsys sync_set_reset "reset"
    always_ff @(posedge clock) begin
        if (reset) begin
            PC_reg <= 0;             // initial PC value is 0 (the memory address where our program starts)
        end else if (take_branch && branch_target != PC_reg - 8) begin
            PC_reg <= branch_target; // update to a taken branch (does not depend on valid bit)
        end else if(taken) begin
            PC_reg <= target[hittarget] + 4;
        end else if (if_valid) begin
            PC_reg <= PC_reg + 4;    // or transition to next PC if valid
        end
    end

    // address of the instruction we're fetching (64 bit memory lines)
    // mem always gives us 8=2^3 bytes, so ignore the last 3 bits
    assign proc2Imem_addr = taken? {target[hittarget][`XLEN-1:3], 3'b0} : {PC_reg[`XLEN-1:3], 3'b0};

    // this mux is because the Imem gives us 64 bits not 32 bits
    assign if_packet.inst = (~if_valid) ? `NOP :
                            PC_reg[2] ? Imem2proc_data[63:32] : Imem2proc_data[31:0];

    assign if_packet.PC  = taken? target[hittarget] : PC_reg;
    assign if_packet.NPC = taken? target[hittarget] + 4 : PC_reg + 4; // pass PC+4 down pipeline w/instruction

    assign if_packet.valid = if_valid;


    /*******************************************************
    //                 Branch Prediction Logic
    *******************************************************/

    assign taken = hit && state > 'd0;
    always_comb begin
        case (PC_reg[11:0])
            tag[0]: begin
                hit = 1;
                hittarget = 2'b00;
            end
            tag[1]: begin
                hit = 1;
                hittarget = 2'b01;
            end
            tag[2]: begin
                hit = 1;
                hittarget = 2'b10;
            end
            tag[3]: begin
                hit = 1;
                hittarget = 2'b11;
            end
            default: begin
                hit = 0;
                hittarget = 2'b00;
            end
        endcase
    end

    always_ff @(posedge clock) begin
        if (reset) begin
            for (i = 0; i < 4;i = i + 1) begin
                tag[i] <= 12'b1111_1111_1111;
                target[i] <= 32'b0;
            end
            tagindex <= 2'b0;
        end else if(take_branch) begin
            tag[tagindex] <= PC_reg[11:0] - 8;
            tagindex <= tagindex + 1;
            target[tagindex] <= branch_target;
        end
    end

    always_ff @(posedge clock) begin
        if (reset) begin
            state <= 2'b11;
        end else if(take_branch && state < 'd3 && !flush) begin
            state <= state + 1;
        end else if(flush && state > 'd0) begin
            state <= state - 1;
        end else begin
            state <= state;
        end
    end
    
endmodule
